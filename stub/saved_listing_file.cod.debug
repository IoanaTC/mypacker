; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33134.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG95575 DB	'log.txt', 00H
$SG95576 DB	'brieflz.dll', 00H
$SG95597 DB	0aH, 00H
	ORG $+2
$SG95577 DB	'msvcrt.dll', 00H
	ORG $+1
$SG95580 DB	'malloc', 00H
	ORG $+1
$SG95581 DB	'memcpy', 00H
	ORG $+5
$SG95582 DB	'blz_depack_safe', 00H
$SG95583 DB	'strlen', 00H
	ORG $+1
$SG95589 DB	'dump_by_stub1.exe', 00H
	ORG $+2
$SG95593 DB	0aH, 0aH, 00H
	ORG $+1
$SG95601 DB	0aH, 0aH, 0aH, 0aH, 00H
	ORG $+3
$SG95602 DB	0aH, 00H
	ORG $+2
$SG95604 DB	0aH, 0aH, 00H
	ORG $+1
$SG95607 DB	'dump_by_stub.exe', 00H
CONST	ENDS
PUBLIC	?StubEntryPoint@@YAXXZ				; StubEntryPoint
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_WriteFile:PROC
EXTRN	__imp_Sleep:PROC
EXTRN	__imp_VirtualAlloc:PROC
EXTRN	__imp_VirtualProtect:PROC
EXTRN	__imp_GetModuleHandleA:PROC
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_LoadLibraryA:PROC
pdata	SEGMENT
$pdata$?StubEntryPoint@@YAXXZ DD imagerel $LN35
	DD	imagerel $LN35+2450
	DD	imagerel $unwind$?StubEntryPoint@@YAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?StubEntryPoint@@YAXXZ DD 020701H
	DD	02d0107H
xdata	ENDS
; Function compile flags: /Odtp
; File D:\licenta\mypacker\stub\stub.cpp
_TEXT	SEGMENT
bytes$ = 64
i$1 = 68
lpOrigLoadAddress$ = 72
offset$2 = 80
hLog$ = 88
pNt$ = 96
type$3 = 104
i$4 = 108
importDescriptor$ = 112
relocation$ = 120
pSec$ = 128
functionEntries$ = 136
pINT$5 = 144
functionID$ = 152
relocationEntry$6 = 160
load_address$ = 168
dllName$ = 176
delta$ = 184
msvcrtDLL$ = 192
size$ = 200
numEntries$ = 204
functionAddress$ = 208
pIAT$7 = 216
relocationBase$8 = 224
exceptionDirectory$ = 232
brieflzDLL$ = 240
blz_depack_safe$ = 248
importDirectory$ = 256
hModuleDLL$9 = 264
relocationDirectory$ = 272
numEntries$10 = 280
oldProtect$ = 288
malloc$ = 296
memcpy$ = 304
hDump1$ = 312
strlen$ = 320
hDump$ = 328
entryPoint$ = 336
?StubEntryPoint@@YAXXZ PROC				; StubEntryPoint

; 17   : void __declspec(noinline) StubEntryPoint() {

$LN35:
  00000	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H

; 18   :     HANDLE hLog = CreateFile("log.txt", FILE_APPEND_DATA, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  00007	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00010	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  00018	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00020	45 33 c9	 xor	 r9d, r9d
  00023	41 b8 02 00 00
	00		 mov	 r8d, 2
  00029	ba 04 00 00 00	 mov	 edx, 4
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG95575
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  0003b	48 89 44 24 58	 mov	 QWORD PTR hLog$[rsp], rax

; 19   :     long unsigned int bytes = 0;

  00040	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR bytes$[rsp], 0

; 20   : 
; 21   :     HMODULE brieflzDLL = LoadLibraryA("brieflz.dll");

  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG95576
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  00055	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR brieflzDLL$[rsp], rax

; 22   :     HMODULE msvcrtDLL = LoadLibraryA("msvcrt.dll");

  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG95577
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  0006a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR msvcrtDLL$[rsp], rax

; 23   : 
; 24   :     if (!brieflzDLL || !msvcrtDLL) {

  00072	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR brieflzDLL$[rsp], 0
  0007b	74 0b		 je	 SHORT $LN15@StubEntryP
  0007d	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR msvcrtDLL$[rsp], 0
  00086	75 05		 jne	 SHORT $LN14@StubEntryP
$LN15@StubEntryP:

; 25   :         return;

  00088	e9 fd 08 00 00	 jmp	 $LN1@StubEntryP
$LN14@StubEntryP:

; 26   :     }
; 27   : 
; 28   :     typedef void* (*MallocFunction)(size_t);
; 29   :     MallocFunction malloc = (MallocFunction)GetProcAddress(msvcrtDLL, "malloc");

  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG95580
  00094	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR msvcrtDLL$[rsp]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  000a2	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR malloc$[rsp], rax

; 30   :     typedef void* (__cdecl *MemcpyFunction)(void*, const void*, size_t);
; 31   :     MemcpyFunction memcpy = (MemcpyFunction)GetProcAddress(msvcrtDLL, "memcpy");

  000aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG95581
  000b1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR msvcrtDLL$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  000bf	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR memcpy$[rsp], rax

; 32   :     typedef unsigned long (*BLZ_DEPACK_FUNCTION)(const void* src, unsigned long src_size, void* dst, unsigned long depacked_size);
; 33   :     BLZ_DEPACK_FUNCTION blz_depack_safe = (BLZ_DEPACK_FUNCTION)GetProcAddress(brieflzDLL, "blz_depack_safe");

  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG95582
  000ce	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR brieflzDLL$[rsp]
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  000dc	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR blz_depack_safe$[rsp], rax

; 34   :     typedef unsigned long (*strlenFunction)(const void* buffer);
; 35   :     strlenFunction strlen = (strlenFunction)GetProcAddress(msvcrtDLL, "strlen");

  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG95583
  000eb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR msvcrtDLL$[rsp]
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  000f9	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR strlen$[rsp], rax

; 36   : 
; 37   :     if(!malloc || !memcpy || !blz_depack_safe) {

  00101	48 83 bc 24 28
	01 00 00 00	 cmp	 QWORD PTR malloc$[rsp], 0
  0010a	74 16		 je	 SHORT $LN17@StubEntryP
  0010c	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR memcpy$[rsp], 0
  00115	74 0b		 je	 SHORT $LN17@StubEntryP
  00117	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR blz_depack_safe$[rsp], 0
  00120	75 05		 jne	 SHORT $LN16@StubEntryP
$LN17@StubEntryP:

; 38   :         return;

  00122	e9 63 08 00 00	 jmp	 $LN1@StubEntryP
$LN16@StubEntryP:

; 39   :     }
; 40   : 
; 41   :     HMODULE load_address = GetModuleHandle(NULL);

  00127	33 c9		 xor	 ecx, ecx
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  0012f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR load_address$[rsp], rax

; 42   :     if (!load_address) {

  00137	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR load_address$[rsp], 0
  00140	75 05		 jne	 SHORT $LN18@StubEntryP

; 43   :         return;

  00142	e9 43 08 00 00	 jmp	 $LN1@StubEntryP
$LN18@StubEntryP:

; 44   :     }
; 45   :     PIMAGE_NT_HEADERS64 pNt = (PIMAGE_NT_HEADERS64)((BYTE*)load_address + sizeof(DWORD));

  00147	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR load_address$[rsp]
  0014f	48 83 c0 04	 add	 rax, 4
  00153	48 89 44 24 60	 mov	 QWORD PTR pNt$[rsp], rax

; 46   :     PIMAGE_SECTION_HEADER pSec = (PIMAGE_SECTION_HEADER)((BYTE*)load_address + sizeof(DWORD) +

  00158	48 8b 44 24 60	 mov	 rax, QWORD PTR pNt$[rsp]
  0015d	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00161	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00165	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR load_address$[rsp]
  0016d	48 8d 84 01 0c
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+268]
  00175	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pSec$[rsp], rax

; 47   :             sizeof(IMAGE_NT_HEADERS64) + pNt->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
; 48   : 
; 49   :     LPVOID lpOrigLoadAddress = VirtualAlloc(NULL, pSec->PointerToRelocations, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

  0017d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSec$[rsp]
  00185	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00188	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  0018e	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  00194	8b d0		 mov	 edx, eax
  00196	33 c9		 xor	 ecx, ecx
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  0019e	48 89 44 24 48	 mov	 QWORD PTR lpOrigLoadAddress$[rsp], rax

; 50   :     if (!lpOrigLoadAddress) {

  001a3	48 83 7c 24 48
	00		 cmp	 QWORD PTR lpOrigLoadAddress$[rsp], 0
  001a9	75 05		 jne	 SHORT $LN19@StubEntryP

; 51   :         return;

  001ab	e9 da 07 00 00	 jmp	 $LN1@StubEntryP
$LN19@StubEntryP:

; 52   :     }
; 53   :     unsigned long size = blz_depack_safe(((BYTE*)load_address + pSec->PointerToRawData), pSec->SizeOfRawData, ((BYTE*)lpOrigLoadAddress), pSec->PointerToRelocations);

  001b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSec$[rsp]
  001b8	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001bb	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR load_address$[rsp]
  001c3	48 03 c8	 add	 rcx, rax
  001c6	48 8b c1	 mov	 rax, rcx
  001c9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pSec$[rsp]
  001d1	44 8b 49 18	 mov	 r9d, DWORD PTR [rcx+24]
  001d5	4c 8b 44 24 48	 mov	 r8, QWORD PTR lpOrigLoadAddress$[rsp]
  001da	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pSec$[rsp]
  001e2	8b 51 10	 mov	 edx, DWORD PTR [rcx+16]
  001e5	48 8b c8	 mov	 rcx, rax
  001e8	ff 94 24 f8 00
	00 00		 call	 QWORD PTR blz_depack_safe$[rsp]
  001ef	89 84 24 c8 00
	00 00		 mov	 DWORD PTR size$[rsp], eax

; 54   :     if (!size) {

  001f6	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR size$[rsp], 0
  001fe	75 05		 jne	 SHORT $LN20@StubEntryP

; 55   :         return;

  00200	e9 85 07 00 00	 jmp	 $LN1@StubEntryP
$LN20@StubEntryP:

; 56   :     }
; 57   :     HANDLE hDump1 = CreateFile("dump_by_stub1.exe", GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  00205	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0020e	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  00216	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0021e	45 33 c9	 xor	 r9d, r9d
  00221	41 b8 02 00 00
	00		 mov	 r8d, 2
  00227	ba 00 00 00 40	 mov	 edx, 1073741824		; 40000000H
  0022c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG95589
  00233	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  00239	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR hDump1$[rsp], rax

; 58   :     WriteFile(hDump1, (BYTE*)lpOrigLoadAddress, pSec->PointerToRelocations, &bytes, NULL);

  00241	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0024a	4c 8d 4c 24 40	 lea	 r9, QWORD PTR bytes$[rsp]
  0024f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSec$[rsp]
  00257	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  0025b	48 8b 54 24 48	 mov	 rdx, QWORD PTR lpOrigLoadAddress$[rsp]
  00260	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR hDump1$[rsp]
  00268	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile

; 59   :     // move pNt to the NT_HEADERS of the original executable
; 60   :     pNt = (PIMAGE_NT_HEADERS64)((BYTE*)lpOrigLoadAddress + ((PIMAGE_DOS_HEADER)lpOrigLoadAddress)->e_lfanew);

  0026e	48 8b 44 24 48	 mov	 rax, QWORD PTR lpOrigLoadAddress$[rsp]
  00273	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00277	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  0027c	48 03 c8	 add	 rcx, rax
  0027f	48 8b c1	 mov	 rax, rcx
  00282	48 89 44 24 60	 mov	 QWORD PTR pNt$[rsp], rax

; 61   :     // begin loader's job
; 62   :     // fill IAT table
; 63   :     LPCSTR functionID = NULL;

  00287	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR functionID$[rsp], 0

; 64   :     LPCSTR dllName = NULL;

  00293	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR dllName$[rsp], 0

; 65   :     FARPROC functionAddress = NULL;

  0029f	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR functionAddress$[rsp], 0
$_import$36:

; 66   : _import:
; 67   :     PIMAGE_DATA_DIRECTORY importDirectory = &pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

  002ab	b8 08 00 00 00	 mov	 eax, 8
  002b0	48 6b c0 01	 imul	 rax, rax, 1
  002b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pNt$[rsp]
  002b9	48 8d 84 01 88
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+136]
  002c1	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR importDirectory$[rsp], rax

; 68   :     if (!importDirectory->Size) {

  002c9	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR importDirectory$[rsp]
  002d1	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  002d5	75 0a		 jne	 SHORT $LN21@StubEntryP

; 69   :         goto _reloc;

  002d7	e9 4a 02 00 00	 jmp	 $LN22@StubEntryP
  002dc	e9 45 02 00 00	 jmp	 $_reloc$37
$LN21@StubEntryP:

; 70   :     }
; 71   :     // interate through import descriptors
; 72   :     PIMAGE_IMPORT_DESCRIPTOR importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)lpOrigLoadAddress + importDirectory->VirtualAddress);

  002e1	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR importDirectory$[rsp]
  002e9	8b 00		 mov	 eax, DWORD PTR [rax]
  002eb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  002f0	48 03 c8	 add	 rcx, rax
  002f3	48 8b c1	 mov	 rax, rcx
  002f6	48 89 44 24 70	 mov	 QWORD PTR importDescriptor$[rsp], rax

; 73   :     if (!importDescriptor) {

  002fb	48 83 7c 24 70
	00		 cmp	 QWORD PTR importDescriptor$[rsp], 0
  00301	75 05		 jne	 SHORT $LN23@StubEntryP

; 74   :         return;

  00303	e9 82 06 00 00	 jmp	 $LN1@StubEntryP
$LN23@StubEntryP:
$LN2@StubEntryP:

; 75   :     }
; 76   :     // solve each dll
; 77   :     while (importDescriptor->OriginalFirstThunk) {

  00308	48 8b 44 24 70	 mov	 rax, QWORD PTR importDescriptor$[rsp]
  0030d	83 38 00	 cmp	 DWORD PTR [rax], 0
  00310	0f 84 10 02 00
	00		 je	 $LN3@StubEntryP

; 78   :         dllName = (LPCSTR)((BYTE*)lpOrigLoadAddress + importDescriptor->Name);

  00316	48 8b 44 24 70	 mov	 rax, QWORD PTR importDescriptor$[rsp]
  0031b	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0031e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  00323	48 03 c8	 add	 rcx, rax
  00326	48 8b c1	 mov	 rax, rcx
  00329	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR dllName$[rsp], rax

; 79   :         //debug
; 80   :         WriteFile(hLog, dllName, strlen(dllName), &bytes, NULL);

  00331	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dllName$[rsp]
  00339	ff 94 24 40 01
	00 00		 call	 QWORD PTR strlen$[rsp]
  00340	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00349	4c 8d 4c 24 40	 lea	 r9, QWORD PTR bytes$[rsp]
  0034e	44 8b c0	 mov	 r8d, eax
  00351	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dllName$[rsp]
  00359	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hLog$[rsp]
  0035e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile

; 81   :         WriteFile(hLog, "\n\n", 2, &bytes, NULL);

  00364	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0036d	4c 8d 4c 24 40	 lea	 r9, QWORD PTR bytes$[rsp]
  00372	41 b8 02 00 00
	00		 mov	 r8d, 2
  00378	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG95593
  0037f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hLog$[rsp]
  00384	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile

; 82   :         //debug
; 83   :         HMODULE hModuleDLL = LoadLibraryA(dllName);

  0038a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dllName$[rsp]
  00392	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  00398	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR hModuleDLL$9[rsp], rax

; 84   :         if (!hModuleDLL) {

  003a0	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR hModuleDLL$9[rsp], 0
  003a9	75 05		 jne	 SHORT $LN24@StubEntryP

; 85   :             return;

  003ab	e9 da 05 00 00	 jmp	 $LN1@StubEntryP
$LN24@StubEntryP:

; 86   :         }
; 87   :         PIMAGE_THUNK_DATA pINT = (PIMAGE_THUNK_DATA)((BYTE*)lpOrigLoadAddress + importDescriptor->OriginalFirstThunk);

  003b0	48 8b 44 24 70	 mov	 rax, QWORD PTR importDescriptor$[rsp]
  003b5	8b 00		 mov	 eax, DWORD PTR [rax]
  003b7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  003bc	48 03 c8	 add	 rcx, rax
  003bf	48 8b c1	 mov	 rax, rcx
  003c2	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pINT$5[rsp], rax

; 88   :         PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)((BYTE*)lpOrigLoadAddress + importDescriptor->FirstThunk);

  003ca	48 8b 44 24 70	 mov	 rax, QWORD PTR importDescriptor$[rsp]
  003cf	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  003d2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  003d7	48 03 c8	 add	 rcx, rax
  003da	48 8b c1	 mov	 rax, rcx
  003dd	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR pIAT$7[rsp], rax
$LN4@StubEntryP:

; 89   :         while (pINT->u1.AddressOfData) {

  003e5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pINT$5[rsp]
  003ed	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  003f1	0f 84 1c 01 00
	00		 je	 $LN5@StubEntryP

; 90   :             //debug
; 91   :             //WriteFile(hLog, &origThunk->u1.AddressOfData, 8, &bytes, NULL);
; 92   :             //WriteFile(hLog, "\n", 2, &bytes, NULL);
; 93   :             //debug
; 94   :             functionID = NULL;

  003f7	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR functionID$[rsp], 0

; 95   :             if (pINT->u1.Ordinal & IMAGE_ORDINAL_FLAG64) {

  00403	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pINT$5[rsp]
  0040b	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00415	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00418	48 23 c1	 and	 rax, rcx
  0041b	48 85 c0	 test	 rax, rax
  0041e	74 1b		 je	 SHORT $LN25@StubEntryP

; 96   :                 // import by ordinal
; 97   :                 functionID = (LPCSTR)(pINT->u1.Ordinal & 0xFFFF);

  00420	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pINT$5[rsp]
  00428	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0042b	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00431	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR functionID$[rsp], rax

; 98   :             } else {

  00439	eb 6a		 jmp	 SHORT $LN26@StubEntryP
$LN25@StubEntryP:

; 99   :                 // import by name
; 100  :                 functionID = (LPCSTR)((PIMAGE_IMPORT_BY_NAME)((BYTE*)lpOrigLoadAddress + pINT->u1.AddressOfData))->Name;

  0043b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pINT$5[rsp]
  00443	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00446	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  0044b	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  00450	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR functionID$[rsp], rax

; 101  :             //debug
; 102  :             WriteFile(hLog, functionID, 16, &bytes, NULL);

  00458	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00461	4c 8d 4c 24 40	 lea	 r9, QWORD PTR bytes$[rsp]
  00466	41 b8 10 00 00
	00		 mov	 r8d, 16
  0046c	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR functionID$[rsp]
  00474	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hLog$[rsp]
  00479	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile

; 103  :             WriteFile(hLog, "\n", 2, &bytes, NULL);

  0047f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00488	4c 8d 4c 24 40	 lea	 r9, QWORD PTR bytes$[rsp]
  0048d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00493	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG95597
  0049a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hLog$[rsp]
  0049f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile
$LN26@StubEntryP:

; 104  :             //debug
; 105  :             }
; 106  :             functionAddress = GetProcAddress(hModuleDLL, functionID);

  004a5	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR functionID$[rsp]
  004ad	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR hModuleDLL$9[rsp]
  004b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  004bb	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR functionAddress$[rsp], rax

; 107  :             if (!functionAddress) {

  004c3	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR functionAddress$[rsp], 0
  004cc	75 05		 jne	 SHORT $LN27@StubEntryP

; 108  :                 return;

  004ce	e9 b7 04 00 00	 jmp	 $LN1@StubEntryP
$LN27@StubEntryP:

; 109  :             }
; 110  :             (pIAT++)->u1.Function = (ULONGLONG)functionAddress;

  004d3	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR pIAT$7[rsp]
  004db	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR functionAddress$[rsp]
  004e3	48 89 08	 mov	 QWORD PTR [rax], rcx
  004e6	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR pIAT$7[rsp]
  004ee	48 83 c0 08	 add	 rax, 8
  004f2	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR pIAT$7[rsp], rax

; 111  :             pINT += 1;

  004fa	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pINT$5[rsp]
  00502	48 83 c0 08	 add	 rax, 8
  00506	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pINT$5[rsp], rax

; 112  :         }

  0050e	e9 d2 fe ff ff	 jmp	 $LN4@StubEntryP
$LN5@StubEntryP:

; 113  :         importDescriptor += 1;

  00513	48 8b 44 24 70	 mov	 rax, QWORD PTR importDescriptor$[rsp]
  00518	48 83 c0 14	 add	 rax, 20
  0051c	48 89 44 24 70	 mov	 QWORD PTR importDescriptor$[rsp], rax

; 114  :     }

  00521	e9 e2 fd ff ff	 jmp	 $LN2@StubEntryP
$LN3@StubEntryP:
$LN22@StubEntryP:
$_reloc$37:

; 115  : /*
; 116  : _bound:
; 117  :     PIMAGE_DATA_DIRECTORY boundDirectory = &pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT];
; 118  :     if (!boundDirectory->Size) {
; 119  :         goto _delayed;
; 120  :     }
; 121  : 
; 122  :     PIMAGE_BOUND_IMPORT_DESCRIPTOR boundDescriptor = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)((BYTE*)lpOrigLoadAddress + boundDirectory->VirtualAddress);
; 123  :     while (boundDescriptor->TimeDateStamp) {
; 124  :         LPCSTR dllName = (LPCSTR)((BYTE*)lpOrigLoadAddress + boundDescriptor->OffsetModuleName);
; 125  :         HMODULE hModule = LoadLibraryA(dllName);
; 126  :         if (!hModule) {
; 127  :             return;
; 128  :         }
; 129  :         if (!boundDescriptor->NumberOfModuleForwarderRefs) {
; 130  :             boundDescriptor += 1;
; 131  :             continue;
; 132  :         }
; 133  : 
; 134  :         PIMAGE_BOUND_FORWARDER_REF forwarderRef = (PIMAGE_BOUND_FORWARDER_REF)(boundDescriptor + 1);
; 135  :         for (unsigned int i = 0; i < boundDescriptor->NumberOfModuleForwarderRefs; i++) {
; 136  :             LPCSTR forwarderDLLName = (LPCSTR)((BYTE*)lpOrigLoadAddress + forwarderRef->OffsetModuleName);
; 137  :             HMODULE hForwarderModule = LoadLibraryA(forwarderDLLName);
; 138  :             if (!hForwarderModule) {
; 139  :                 return;
; 140  :             }
; 141  :             forwarderRef += 1;
; 142  :         }
; 143  :         boundDescriptor = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)forwarderRef;
; 144  :     }
; 145  : 
; 146  : _delayed:
; 147  :     PIMAGE_DATA_DIRECTORY delayedDirectory = &pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];
; 148  :     if (!delayedDirectory->Size) {
; 149  :         goto _reloc;
; 150  :     }
; 151  : 
; 152  :     PIMAGE_DELAYLOAD_DESCRIPTOR delayloadDescriptor = (PIMAGE_DELAYLOAD_DESCRIPTOR)((BYTE*)lpOrigLoadAddress + delayedDirectory->VirtualAddress);
; 153  :     while (delayloadDescriptor->DllNameRVA) {
; 154  :         LPCSTR dllName = (LPCSTR)((BYTE*)lpOrigLoadAddress + delayloadDescriptor->DllNameRVA);
; 155  :         HMODULE hDelayModule = LoadLibraryA(dllName);
; 156  :         if (!hDelayModule) {
; 157  :             return;
; 158  :         }
; 159  : 
; 160  :         PIMAGE_THUNK_DATA delayedOriginalThunk = (PIMAGE_THUNK_DATA)((BYTE*)lpOrigLoadAddress + delayloadDescriptor->ImportNameTableRVA);
; 161  :         PIMAGE_THUNK_DATA delayedFirstThunk = (PIMAGE_THUNK_DATA)((BYTE*)lpOrigLoadAddress + delayloadDescriptor->ImportAddressTableRVA);
; 162  :         while (delayedFirstThunk->u1.AddressOfData) {
; 163  :             FARPROC delayedFunction = NULL;
; 164  :             if (delayedOriginalThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) {
; 165  :                 delayedFunction = GetProcAddress(hDelayModule, (LPCSTR)(delayedOriginalThunk->u1.Ordinal & 0xFFFF));
; 166  :             } else {
; 167  :                 delayedFunction = GetProcAddress(hDelayModule, ((PIMAGE_IMPORT_BY_NAME)((BYTE*)lpOrigLoadAddress + delayedOriginalThunk->u1.AddressOfData))->Name);
; 168  :             }
; 169  :             if (!delayedFunction) {
; 170  :                 return;
; 171  :             }
; 172  :             delayedFirstThunk->u1.Function = (unsigned long long)delayedFunction;
; 173  :             delayedOriginalThunk += 1;
; 174  :             delayedFirstThunk += 1;
; 175  :         }
; 176  :         delayloadDescriptor += 1;
; 177  :     }
; 178  : */
; 179  : _reloc:
; 180  :     ULONGLONG delta = (ULONGLONG)(pNt->OptionalHeader.ImageBase - (ULONGLONG)lpOrigLoadAddress);

  00526	48 8b 44 24 60	 mov	 rax, QWORD PTR pNt$[rsp]
  0052b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  00530	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00534	48 2b c1	 sub	 rax, rcx
  00537	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR delta$[rsp], rax

; 181  :     PIMAGE_DATA_DIRECTORY relocationDirectory = &pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

  0053f	b8 08 00 00 00	 mov	 eax, 8
  00544	48 6b c0 05	 imul	 rax, rax, 5
  00548	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pNt$[rsp]
  0054d	48 8d 84 01 88
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+136]
  00555	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR relocationDirectory$[rsp], rax

; 182  :     if (!relocationDirectory->Size) {

  0055d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR relocationDirectory$[rsp]
  00565	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00569	75 0a		 jne	 SHORT $LN28@StubEntryP

; 183  :        // goto _exception;
; 184  :         goto _exception;

  0056b	e9 2e 02 00 00	 jmp	 $LN29@StubEntryP
  00570	e9 29 02 00 00	 jmp	 $_exception$38
$LN28@StubEntryP:

; 185  :     }
; 186  : 
; 187  :     PIMAGE_BASE_RELOCATION relocation = (PIMAGE_BASE_RELOCATION)((BYTE*)lpOrigLoadAddress + relocationDirectory->VirtualAddress);

  00575	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR relocationDirectory$[rsp]
  0057d	8b 00		 mov	 eax, DWORD PTR [rax]
  0057f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  00584	48 03 c8	 add	 rcx, rax
  00587	48 8b c1	 mov	 rax, rcx
  0058a	48 89 44 24 78	 mov	 QWORD PTR relocation$[rsp], rax
$LN6@StubEntryP:

; 188  :     //debug
; 189  :     //WriteFile(hLog, relocation, relocation->SizeOfBlock, &bytes, NULL);
; 190  :     //WriteFile(hLog, "\n", 2, &bytes, NULL);
; 191  :     //debug
; 192  : 
; 193  :     while (relocation->VirtualAddress) {

  0058f	48 8b 44 24 78	 mov	 rax, QWORD PTR relocation$[rsp]
  00594	83 38 00	 cmp	 DWORD PTR [rax], 0
  00597	0f 84 f6 01 00
	00		 je	 $LN7@StubEntryP

; 194  :         BYTE* relocationBase = (BYTE*)lpOrigLoadAddress + relocation->VirtualAddress;

  0059d	48 8b 44 24 78	 mov	 rax, QWORD PTR relocation$[rsp]
  005a2	8b 00		 mov	 eax, DWORD PTR [rax]
  005a4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  005a9	48 03 c8	 add	 rcx, rax
  005ac	48 8b c1	 mov	 rax, rcx
  005af	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR relocationBase$8[rsp], rax

; 195  : 
; 196  :         unsigned long long numEntries = (relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);

  005b7	48 8b 44 24 78	 mov	 rax, QWORD PTR relocation$[rsp]
  005bc	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  005bf	48 83 e8 08	 sub	 rax, 8
  005c3	33 d2		 xor	 edx, edx
  005c5	b9 02 00 00 00	 mov	 ecx, 2
  005ca	48 f7 f1	 div	 rcx
  005cd	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR numEntries$10[rsp], rax

; 197  :             //debug
; 198  :             WriteFile(hLog, &numEntries, 8, &bytes, NULL);

  005d5	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  005de	4c 8d 4c 24 40	 lea	 r9, QWORD PTR bytes$[rsp]
  005e3	41 b8 08 00 00
	00		 mov	 r8d, 8
  005e9	48 8d 94 24 18
	01 00 00	 lea	 rdx, QWORD PTR numEntries$10[rsp]
  005f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hLog$[rsp]
  005f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile

; 199  :             WriteFile(hLog, "\n\n\n\n", 4, &bytes, NULL);

  005fc	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00605	4c 8d 4c 24 40	 lea	 r9, QWORD PTR bytes$[rsp]
  0060a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00610	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG95601
  00617	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hLog$[rsp]
  0061c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile

; 200  :             //debug
; 201  :         PWORD relocationEntry = reinterpret_cast<PWORD>((BYTE*)(relocation + 1));

  00622	48 8b 44 24 78	 mov	 rax, QWORD PTR relocation$[rsp]
  00627	48 83 c0 08	 add	 rax, 8
  0062b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR relocationEntry$6[rsp], rax

; 202  :         for (unsigned int i = 0; i < numEntries; i++) {

  00633	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0
  0063b	eb 0a		 jmp	 SHORT $LN10@StubEntryP
$LN8@StubEntryP:
  0063d	8b 44 24 6c	 mov	 eax, DWORD PTR i$4[rsp]
  00641	ff c0		 inc	 eax
  00643	89 44 24 6c	 mov	 DWORD PTR i$4[rsp], eax
$LN10@StubEntryP:
  00647	8b 44 24 6c	 mov	 eax, DWORD PTR i$4[rsp]
  0064b	48 3b 84 24 18
	01 00 00	 cmp	 rax, QWORD PTR numEntries$10[rsp]
  00653	0f 83 1d 01 00
	00		 jae	 $LN9@StubEntryP

; 203  :             WORD type = *relocationEntry >> 12;

  00659	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR relocationEntry$6[rsp]
  00661	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00664	c1 f8 0c	 sar	 eax, 12
  00667	66 89 44 24 68	 mov	 WORD PTR type$3[rsp], ax

; 204  :             WORD offset = *relocationEntry & 0x0FFF;

  0066c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR relocationEntry$6[rsp]
  00674	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00677	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0067c	66 89 44 24 50	 mov	 WORD PTR offset$2[rsp], ax

; 205  :             //debug
; 206  :             WriteFile(hLog, relocationEntry, 8, &bytes, NULL);

  00681	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0068a	4c 8d 4c 24 40	 lea	 r9, QWORD PTR bytes$[rsp]
  0068f	41 b8 08 00 00
	00		 mov	 r8d, 8
  00695	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR relocationEntry$6[rsp]
  0069d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hLog$[rsp]
  006a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile

; 207  :             WriteFile(hLog, "\n", 1, &bytes, NULL);

  006a8	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  006b1	4c 8d 4c 24 40	 lea	 r9, QWORD PTR bytes$[rsp]
  006b6	41 b8 01 00 00
	00		 mov	 r8d, 1
  006bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG95602
  006c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hLog$[rsp]
  006c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile

; 208  :             //debug
; 209  :             if(type == IMAGE_REL_BASED_DIR64) {

  006ce	0f b7 44 24 68	 movzx	 eax, WORD PTR type$3[rsp]
  006d3	83 f8 0a	 cmp	 eax, 10
  006d6	75 2a		 jne	 SHORT $LN30@StubEntryP

; 210  :                 //*(ULONGLONG*)(relocationBase + offset) += /*(ULONGLONG)load_address*/ + (ULONGLONG) lpOrigLoadAddress;
; 211  :                 *(ULONGLONG*)(relocationBase + offset) += delta;

  006d8	0f b7 44 24 50	 movzx	 eax, WORD PTR offset$2[rsp]
  006dd	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR relocationBase$8[rsp]
  006e5	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  006e9	48 03 84 24 b8
	00 00 00	 add	 rax, QWORD PTR delta$[rsp]
  006f1	0f b7 4c 24 50	 movzx	 ecx, WORD PTR offset$2[rsp]
  006f6	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR relocationBase$8[rsp]
  006fe	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax
$LN30@StubEntryP:

; 212  :                 //debug
; 213  :                 //WriteFile(hLog, (relocationBase + offset), 8, &bytes, NULL);
; 214  :                 //WriteFile(hLog, "\n", 1, &bytes, NULL);
; 215  :                 //debug
; 216  :                 //*(ULONGLONG*)(relocationBase + offset) -= (ULONGLONG) pNt->OptionalHeader.ImageBase;
; 217  :             }
; 218  :             //debug
; 219  :             WriteFile(hLog, (relocationBase + offset), 8, &bytes, NULL);

  00702	0f b7 44 24 50	 movzx	 eax, WORD PTR offset$2[rsp]
  00707	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR relocationBase$8[rsp]
  0070f	48 03 c8	 add	 rcx, rax
  00712	48 8b c1	 mov	 rax, rcx
  00715	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0071e	4c 8d 4c 24 40	 lea	 r9, QWORD PTR bytes$[rsp]
  00723	41 b8 08 00 00
	00		 mov	 r8d, 8
  00729	48 8b d0	 mov	 rdx, rax
  0072c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hLog$[rsp]
  00731	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile

; 220  :             WriteFile(hLog, "\n\n", 1, &bytes, NULL);

  00737	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00740	4c 8d 4c 24 40	 lea	 r9, QWORD PTR bytes$[rsp]
  00745	41 b8 01 00 00
	00		 mov	 r8d, 1
  0074b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG95604
  00752	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hLog$[rsp]
  00757	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile

; 221  :             //debug
; 222  :             relocationEntry += 1;

  0075d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR relocationEntry$6[rsp]
  00765	48 83 c0 02	 add	 rax, 2
  00769	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR relocationEntry$6[rsp], rax

; 223  :         }

  00771	e9 c7 fe ff ff	 jmp	 $LN8@StubEntryP
$LN9@StubEntryP:

; 224  :         relocation = (PIMAGE_BASE_RELOCATION)((BYTE*)relocation + relocation->SizeOfBlock);

  00776	48 8b 44 24 78	 mov	 rax, QWORD PTR relocation$[rsp]
  0077b	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0077e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR relocation$[rsp]
  00783	48 03 c8	 add	 rcx, rax
  00786	48 8b c1	 mov	 rax, rcx
  00789	48 89 44 24 78	 mov	 QWORD PTR relocation$[rsp], rax

; 225  :     }

  0078e	e9 fc fd ff ff	 jmp	 $LN6@StubEntryP
$LN7@StubEntryP:

; 226  :     Sleep(30000);

  00793	b9 30 75 00 00	 mov	 ecx, 30000		; 00007530H
  00798	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep
$LN29@StubEntryP:
$_exception$38:

; 227  : _exception:
; 228  :     PIMAGE_DATA_DIRECTORY exceptionDirectory = &pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];

  0079e	b8 08 00 00 00	 mov	 eax, 8
  007a3	48 6b c0 03	 imul	 rax, rax, 3
  007a7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pNt$[rsp]
  007ac	48 8d 84 01 88
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+136]
  007b4	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR exceptionDirectory$[rsp], rax

; 229  :     if (!exceptionDirectory->Size) {

  007bc	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR exceptionDirectory$[rsp]
  007c4	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  007c8	75 0a		 jne	 SHORT $LN31@StubEntryP

; 230  :         goto _run;

  007ca	e9 f6 00 00 00	 jmp	 $LN32@StubEntryP
  007cf	e9 f1 00 00 00	 jmp	 $_run$39
$LN31@StubEntryP:

; 231  :     }
; 232  :     PIMAGE_RUNTIME_FUNCTION_ENTRY functionEntries = (PIMAGE_RUNTIME_FUNCTION_ENTRY)((BYTE*)lpOrigLoadAddress + exceptionDirectory->VirtualAddress);

  007d4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR exceptionDirectory$[rsp]
  007dc	8b 00		 mov	 eax, DWORD PTR [rax]
  007de	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  007e3	48 03 c8	 add	 rcx, rax
  007e6	48 8b c1	 mov	 rax, rcx
  007e9	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR functionEntries$[rsp], rax

; 233  :     DWORD numEntries = exceptionDirectory->Size / sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY);

  007f1	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR exceptionDirectory$[rsp]
  007f9	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  007fc	33 d2		 xor	 edx, edx
  007fe	b9 0c 00 00 00	 mov	 ecx, 12
  00803	48 f7 f1	 div	 rcx
  00806	89 84 24 cc 00
	00 00		 mov	 DWORD PTR numEntries$[rsp], eax

; 234  : 
; 235  :     for (DWORD i = 0; i < numEntries; ++i) {

  0080d	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00815	eb 0a		 jmp	 SHORT $LN13@StubEntryP
$LN11@StubEntryP:
  00817	8b 44 24 44	 mov	 eax, DWORD PTR i$1[rsp]
  0081b	ff c0		 inc	 eax
  0081d	89 44 24 44	 mov	 DWORD PTR i$1[rsp], eax
$LN13@StubEntryP:
  00821	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR numEntries$[rsp]
  00828	39 44 24 44	 cmp	 DWORD PTR i$1[rsp], eax
  0082c	0f 83 93 00 00
	00		 jae	 $LN12@StubEntryP

; 236  :         functionEntries[i].BeginAddress += delta;

  00832	8b 44 24 44	 mov	 eax, DWORD PTR i$1[rsp]
  00836	48 6b c0 0c	 imul	 rax, rax, 12
  0083a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR functionEntries$[rsp]
  00842	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00845	48 03 84 24 b8
	00 00 00	 add	 rax, QWORD PTR delta$[rsp]
  0084d	8b 4c 24 44	 mov	 ecx, DWORD PTR i$1[rsp]
  00851	48 6b c9 0c	 imul	 rcx, rcx, 12
  00855	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR functionEntries$[rsp]
  0085d	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 237  :         functionEntries[i].EndAddress += delta;

  00860	8b 44 24 44	 mov	 eax, DWORD PTR i$1[rsp]
  00864	48 6b c0 0c	 imul	 rax, rax, 12
  00868	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR functionEntries$[rsp]
  00870	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00874	48 03 84 24 b8
	00 00 00	 add	 rax, QWORD PTR delta$[rsp]
  0087c	8b 4c 24 44	 mov	 ecx, DWORD PTR i$1[rsp]
  00880	48 6b c9 0c	 imul	 rcx, rcx, 12
  00884	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR functionEntries$[rsp]
  0088c	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax

; 238  :         functionEntries[i].UnwindData += delta;

  00890	8b 44 24 44	 mov	 eax, DWORD PTR i$1[rsp]
  00894	48 6b c0 0c	 imul	 rax, rax, 12
  00898	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR functionEntries$[rsp]
  008a0	8b 44 01 08	 mov	 eax, DWORD PTR [rcx+rax+8]
  008a4	48 03 84 24 b8
	00 00 00	 add	 rax, QWORD PTR delta$[rsp]
  008ac	8b 4c 24 44	 mov	 ecx, DWORD PTR i$1[rsp]
  008b0	48 6b c9 0c	 imul	 rcx, rcx, 12
  008b4	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR functionEntries$[rsp]
  008bc	89 44 0a 08	 mov	 DWORD PTR [rdx+rcx+8], eax

; 239  :     }

  008c0	e9 52 ff ff ff	 jmp	 $LN11@StubEntryP
$LN12@StubEntryP:
$LN32@StubEntryP:
$_run$39:

; 240  : _run:
; 241  :     HANDLE hDump = CreateFile("dump_by_stub.exe", GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  008c5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  008ce	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  008d6	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  008de	45 33 c9	 xor	 r9d, r9d
  008e1	41 b8 02 00 00
	00		 mov	 r8d, 2
  008e7	ba 00 00 00 40	 mov	 edx, 1073741824		; 40000000H
  008ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG95607
  008f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  008f9	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR hDump$[rsp], rax

; 242  :     WriteFile(hDump, (BYTE*)lpOrigLoadAddress, pSec->PointerToRelocations, &bytes, NULL);

  00901	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0090a	4c 8d 4c 24 40	 lea	 r9, QWORD PTR bytes$[rsp]
  0090f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSec$[rsp]
  00917	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  0091b	48 8b 54 24 48	 mov	 rdx, QWORD PTR lpOrigLoadAddress$[rsp]
  00920	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR hDump$[rsp]
  00928	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile

; 243  : 
; 244  :     DWORD oldProtect;
; 245  :     if (!VirtualProtect(lpOrigLoadAddress, pSec->PointerToRelocations, PAGE_EXECUTE_READ, &oldProtect)) {

  0092e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSec$[rsp]
  00936	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00939	4c 8d 8c 24 20
	01 00 00	 lea	 r9, QWORD PTR oldProtect$[rsp]
  00941	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00947	8b d0		 mov	 edx, eax
  00949	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  0094e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualProtect
  00954	85 c0		 test	 eax, eax
  00956	75 02		 jne	 SHORT $LN33@StubEntryP

; 246  :         return;

  00958	eb 30		 jmp	 SHORT $LN1@StubEntryP
$LN33@StubEntryP:

; 247  :     }
; 248  : 
; 249  :     pNt->OptionalHeader.ImageBase = (ULONGLONG)lpOrigLoadAddress;

  0095a	48 8b 44 24 60	 mov	 rax, QWORD PTR pNt$[rsp]
  0095f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  00964	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx -> aici crapa (deci eu am schimbat permisiunile sa nu mai aiba write si dupa am scris ca o duda)

; 250  :     BYTE* entryPoint = (BYTE*)lpOrigLoadAddress + pNt->OptionalHeader.AddressOfEntryPoint;

  00968	48 8b 44 24 60	 mov	 rax, QWORD PTR pNt$[rsp]
  0096d	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00970	48 8b 4c 24 48	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  00975	48 03 c8	 add	 rcx, rax
  00978	48 8b c1	 mov	 rax, rcx
  0097b	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR entryPoint$[rsp], rax

; 251  :     ((void(*)())entryPoint)();

  00983	ff 94 24 50 01
	00 00		 call	 QWORD PTR entryPoint$[rsp]
$LN1@StubEntryP:

; 252  : }

  0098a	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  00991	c3		 ret	 0
?StubEntryPoint@@YAXXZ ENDP				; StubEntryPoint
_TEXT	ENDS
END

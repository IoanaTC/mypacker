; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33134.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?genv@@3UGlobalExternVariables@@A		; genv
CONST	SEGMENT
$SG96927 DB	'log.txt', 00H
$SG96928 DB	'brieflz.dll', 00H
	ORG $+4
$SG96929 DB	'msvcrt.dll', 00H
	ORG $+1
$SG96932 DB	'malloc', 00H
	ORG $+1
$SG96933 DB	'memcpy', 00H
	ORG $+1
$SG96934 DB	'memset', 00H
	ORG $+5
$SG96935 DB	'blz_depack_safe', 00H
$SG96936 DB	'strlen', 00H
	ORG $+1
$SG96942 DB	'dump_by_stub1.exe', 00H
	ORG $+2
$SG96963 DB	0aH, 0aH, 0aH, 0aH, 00H
	ORG $+7
$SG96965 DB	'dump_by_stub.exe', 00H
CONST	ENDS
A$A	SEGMENT
?genv@@3UGlobalExternVariables@@A	ORG $+8		; genv
A$A	ENDS
PUBLIC	?getQwordLE@@YA_KPEAEH@Z			; getQwordLE
PUBLIC	StubLoadPE
PUBLIC	?StubEntryPoint@@YAHPEAUHINSTANCE__@@KPEAX@Z	; StubEntryPoint
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_WriteFile:PROC
EXTRN	__imp_VirtualAlloc:PROC
EXTRN	__imp_VirtualProtect:PROC
EXTRN	__imp_GetModuleHandleA:PROC
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_LoadLibraryA:PROC
pdata	SEGMENT
$pdata$StubLoadPE DD imagerel $LN51
	DD	imagerel $LN51+2765
	DD	imagerel $unwind$StubLoadPE
$pdata$?StubEntryPoint@@YAHPEAUHINSTANCE__@@KPEAX@Z DD imagerel $LN9
	DD	imagerel $LN9+35
	DD	imagerel $unwind$?StubEntryPoint@@YAHPEAUHINSTANCE__@@KPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$StubLoadPE DD 020701H
	DD	03b0107H
$unwind$?StubEntryPoint@@YAHPEAUHINSTANCE__@@KPEAX@Z DD 011201H
	DD	02212H
xdata	ENDS
; Function compile flags: /Odtp
; File D:\licenta\mypacker\stub\stub.cpp
_TEXT	SEGMENT
tv64 = 0
hModule$ = 32
ul_reason_for_call$ = 40
lpReserved$ = 48
?StubEntryPoint@@YAHPEAUHINSTANCE__@@KPEAX@Z PROC	; StubEntryPoint

; 216  : BOOL APIENTRY StubEntryPoint (HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 217  : 
; 218  :     switch (ul_reason_for_call)

  00012	8b 44 24 28	 mov	 eax, DWORD PTR ul_reason_for_call$[rsp]
  00016	89 04 24	 mov	 DWORD PTR tv64[rsp], eax

; 219  :     {
; 220  :     case DLL_PROCESS_ATTACH:
; 221  :         // Code to run when the DLL is loaded
; 222  :         break;
; 223  :     case DLL_THREAD_ATTACH:
; 224  :         // Code to run when a new thread is created
; 225  :         break;
; 226  :     case DLL_THREAD_DETACH:
; 227  :         // Code to run when a thread ends
; 228  :         break;
; 229  :     case DLL_PROCESS_DETACH:
; 230  :         // Code to run when the DLL is unloaded
; 231  :         break;
; 232  :     }
; 233  :     return TRUE;

  00019	b8 01 00 00 00	 mov	 eax, 1

; 234  : }

  0001e	48 83 c4 18	 add	 rsp, 24
  00022	c3		 ret	 0
?StubEntryPoint@@YAHPEAUHINSTANCE__@@KPEAX@Z ENDP	; StubEntryPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\licenta\mypacker\stub\stub.cpp
_TEXT	SEGMENT
lpOrigLoadAddress$ = 64
offset$1 = 72
pNt$ = 80
bytes$ = 88
boundDescriptor$ = 96
type$2 = 104
i$3 = 108
i$4 = 112
pSec$ = 120
importDescriptor$ = 128
relocation$ = 136
pINT$5 = 144
delayloadDescriptor$ = 152
msvcrtDLL$ = 160
load_address$ = 168
delayedINT$6 = 176
delayedIAT$7 = 184
relocationEntry$8 = 192
functionID$ = 200
forwarderRef$9 = 208
delayedFunction$10 = 216
size$ = 224
hDelayModule$11 = 232
functionAddress$ = 240
pIAT$12 = 248
brieflzDLL$ = 256
blz_depack_safe$ = 264
importDirectory$ = 272
dllName$ = 280
hModuleDLL$13 = 288
boundDirectory$ = 296
delayedDirectory$ = 304
relocationDirectory$ = 312
hLog$ = 320
numEntries$14 = 328
relocationBase$15 = 336
oldProtect$ = 344
malloc$ = 352
memcpy$ = 360
hDump1$ = 368
dllName$16 = 376
hModule$17 = 384
forwarderDLLName$18 = 392
hForwarderModule$19 = 400
dllName$20 = 408
delta$ = 416
hDump$ = 424
entryPoint$ = 432
memset$ = 440
strlen$ = 448
pLoadConfig_main$ = 456
StubLoadPE PROC

; 24   : extern "C" __declspec(dllexport) void StubLoadPE() {

$LN51:
  00000	48 81 ec d8 01
	00 00		 sub	 rsp, 472		; 000001d8H

; 25   : 
; 26   :     HANDLE hLog = CreateFile("log.txt", FILE_APPEND_DATA, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  00007	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00010	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  00018	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00020	45 33 c9	 xor	 r9d, r9d
  00023	41 b8 02 00 00
	00		 mov	 r8d, 2
  00029	ba 04 00 00 00	 mov	 edx, 4
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG96927
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  0003b	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR hLog$[rsp], rax

; 27   :     long unsigned int bytes = 0;

  00043	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR bytes$[rsp], 0

; 28   : 
; 29   :     HMODULE brieflzDLL = LoadLibraryA("brieflz.dll");

  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG96928
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  00058	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR brieflzDLL$[rsp], rax

; 30   :     HMODULE msvcrtDLL = LoadLibraryA("msvcrt.dll");

  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG96929
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  0006d	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR msvcrtDLL$[rsp], rax

; 31   : 
; 32   :     if (!brieflzDLL || !msvcrtDLL) {

  00075	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR brieflzDLL$[rsp], 0
  0007e	74 0b		 je	 SHORT $LN21@StubLoadPE
  00080	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR msvcrtDLL$[rsp], 0
  00089	75 05		 jne	 SHORT $LN20@StubLoadPE
$LN21@StubLoadPE:

; 33   :         return;

  0008b	e9 35 0a 00 00	 jmp	 $LN1@StubLoadPE
$LN20@StubLoadPE:

; 34   :     }
; 35   : 
; 36   :     typedef void* (*MallocFunction)(size_t);
; 37   :     MallocFunction malloc = (MallocFunction)GetProcAddress(msvcrtDLL, "malloc");

  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG96932
  00097	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR msvcrtDLL$[rsp]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  000a5	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR malloc$[rsp], rax

; 38   :     typedef void* (__cdecl *MemcpyFunction)(void*, const void*, size_t);
; 39   :     MemcpyFunction memcpy = (MemcpyFunction)GetProcAddress(msvcrtDLL, "memcpy");

  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG96933
  000b4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR msvcrtDLL$[rsp]
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  000c2	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR memcpy$[rsp], rax

; 40   :     typedef void* (__cdecl *MemsetFunction)(void*, int, size_t);
; 41   :     MemsetFunction memset = (MemsetFunction)GetProcAddress(msvcrtDLL, "memset");

  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG96934
  000d1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR msvcrtDLL$[rsp]
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  000df	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR memset$[rsp], rax

; 42   :     typedef unsigned long (*BLZ_DEPACK_FUNCTION)(const void* src, unsigned long src_size, void* dst, unsigned long depacked_size);
; 43   :     BLZ_DEPACK_FUNCTION blz_depack_safe = (BLZ_DEPACK_FUNCTION)GetProcAddress(brieflzDLL, "blz_depack_safe");

  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG96935
  000ee	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR brieflzDLL$[rsp]
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  000fc	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR blz_depack_safe$[rsp], rax

; 44   :     typedef unsigned long (*strlenFunction)(const void* buffer);
; 45   :     strlenFunction strlen = (strlenFunction)GetProcAddress(msvcrtDLL, "strlen");

  00104	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG96936
  0010b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR msvcrtDLL$[rsp]
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00119	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR strlen$[rsp], rax

; 46   : 
; 47   :     if(!malloc || !memcpy || !blz_depack_safe) {

  00121	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR malloc$[rsp], 0
  0012a	74 16		 je	 SHORT $LN23@StubLoadPE
  0012c	48 83 bc 24 68
	01 00 00 00	 cmp	 QWORD PTR memcpy$[rsp], 0
  00135	74 0b		 je	 SHORT $LN23@StubLoadPE
  00137	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR blz_depack_safe$[rsp], 0
  00140	75 05		 jne	 SHORT $LN22@StubLoadPE
$LN23@StubLoadPE:

; 48   :         return;

  00142	e9 7e 09 00 00	 jmp	 $LN1@StubLoadPE
$LN22@StubLoadPE:

; 49   :     }
; 50   : 
; 51   :     HMODULE load_address = GetModuleHandle(NULL);

  00147	33 c9		 xor	 ecx, ecx
  00149	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  0014f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR load_address$[rsp], rax

; 52   :     if (!load_address) {

  00157	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR load_address$[rsp], 0
  00160	75 05		 jne	 SHORT $LN24@StubLoadPE

; 53   :         return;

  00162	e9 5e 09 00 00	 jmp	 $LN1@StubLoadPE
$LN24@StubLoadPE:

; 54   :     }
; 55   :     PIMAGE_NT_HEADERS64 pNt = (PIMAGE_NT_HEADERS64)((BYTE*)load_address + sizeof(DWORD));

  00167	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR load_address$[rsp]
  0016f	48 83 c0 04	 add	 rax, 4
  00173	48 89 44 24 50	 mov	 QWORD PTR pNt$[rsp], rax

; 56   :     PIMAGE_SECTION_HEADER pSec = (PIMAGE_SECTION_HEADER)((BYTE*)load_address + sizeof(DWORD) +

  00178	48 8b 44 24 50	 mov	 rax, QWORD PTR pNt$[rsp]
  0017d	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00181	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00185	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR load_address$[rsp]
  0018d	48 8d 84 01 0c
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+268]
  00195	48 89 44 24 78	 mov	 QWORD PTR pSec$[rsp], rax

; 57   :             sizeof(IMAGE_NT_HEADERS64) + pNt->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
; 58   :     PIMAGE_LOAD_CONFIG_DIRECTORY pLoadConfig_main = (PIMAGE_LOAD_CONFIG_DIRECTORY)((BYTE*)load_address + pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress);

  0019a	b8 08 00 00 00	 mov	 eax, 8
  0019f	48 6b c0 0a	 imul	 rax, rax, 10
  001a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pNt$[rsp]
  001a8	8b 84 01 88 00
	00 00		 mov	 eax, DWORD PTR [rcx+rax+136]
  001af	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR load_address$[rsp]
  001b7	48 03 c8	 add	 rcx, rax
  001ba	48 8b c1	 mov	 rax, rcx
  001bd	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR pLoadConfig_main$[rsp], rax

; 59   : 
; 60   :     LPVOID lpOrigLoadAddress = VirtualAlloc(NULL, pSec->PointerToRelocations, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

  001c5	48 8b 44 24 78	 mov	 rax, QWORD PTR pSec$[rsp]
  001ca	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  001cd	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  001d3	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  001d9	8b d0		 mov	 edx, eax
  001db	33 c9		 xor	 ecx, ecx
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  001e3	48 89 44 24 40	 mov	 QWORD PTR lpOrigLoadAddress$[rsp], rax

; 61   :     if (!lpOrigLoadAddress) {

  001e8	48 83 7c 24 40
	00		 cmp	 QWORD PTR lpOrigLoadAddress$[rsp], 0
  001ee	75 05		 jne	 SHORT $LN25@StubLoadPE

; 62   :         return;

  001f0	e9 d0 08 00 00	 jmp	 $LN1@StubLoadPE
$LN25@StubLoadPE:

; 63   :     }
; 64   :     unsigned long size = blz_depack_safe(((BYTE*)load_address + pSec->PointerToRawData), pSec->SizeOfRawData, ((BYTE*)lpOrigLoadAddress), pSec->PointerToRelocations);

  001f5	48 8b 44 24 78	 mov	 rax, QWORD PTR pSec$[rsp]
  001fa	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001fd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR load_address$[rsp]
  00205	48 03 c8	 add	 rcx, rax
  00208	48 8b c1	 mov	 rax, rcx
  0020b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pSec$[rsp]
  00210	44 8b 49 18	 mov	 r9d, DWORD PTR [rcx+24]
  00214	4c 8b 44 24 40	 mov	 r8, QWORD PTR lpOrigLoadAddress$[rsp]
  00219	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pSec$[rsp]
  0021e	8b 51 10	 mov	 edx, DWORD PTR [rcx+16]
  00221	48 8b c8	 mov	 rcx, rax
  00224	ff 94 24 08 01
	00 00		 call	 QWORD PTR blz_depack_safe$[rsp]
  0022b	89 84 24 e0 00
	00 00		 mov	 DWORD PTR size$[rsp], eax

; 65   :     if (!size) {

  00232	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR size$[rsp], 0
  0023a	75 05		 jne	 SHORT $LN26@StubLoadPE

; 66   :         return;

  0023c	e9 84 08 00 00	 jmp	 $LN1@StubLoadPE
$LN26@StubLoadPE:

; 67   :     }
; 68   :     HANDLE hDump1 = CreateFile("dump_by_stub1.exe", GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  00241	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0024a	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  00252	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0025a	45 33 c9	 xor	 r9d, r9d
  0025d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00263	ba 00 00 00 40	 mov	 edx, 1073741824		; 40000000H
  00268	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG96942
  0026f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  00275	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR hDump1$[rsp], rax

; 69   :     WriteFile(hDump1, (BYTE*)lpOrigLoadAddress, pSec->PointerToRelocations, &bytes, NULL);

  0027d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00286	4c 8d 4c 24 58	 lea	 r9, QWORD PTR bytes$[rsp]
  0028b	48 8b 44 24 78	 mov	 rax, QWORD PTR pSec$[rsp]
  00290	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  00294	48 8b 54 24 40	 mov	 rdx, QWORD PTR lpOrigLoadAddress$[rsp]
  00299	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR hDump1$[rsp]
  002a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile

; 70   :     // move pNt to the NT_HEADERS of the original executable
; 71   :     pNt = (PIMAGE_NT_HEADERS64)((BYTE*)lpOrigLoadAddress + ((PIMAGE_DOS_HEADER)lpOrigLoadAddress)->e_lfanew);

  002a7	48 8b 44 24 40	 mov	 rax, QWORD PTR lpOrigLoadAddress$[rsp]
  002ac	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  002b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  002b5	48 03 c8	 add	 rcx, rax
  002b8	48 8b c1	 mov	 rax, rcx
  002bb	48 89 44 24 50	 mov	 QWORD PTR pNt$[rsp], rax

; 72   :     // begin loader's job
; 73   :     // fill IAT table
; 74   :     LPCSTR functionID = NULL;

  002c0	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR functionID$[rsp], 0

; 75   :     LPCSTR dllName = NULL;

  002cc	48 c7 84 24 18
	01 00 00 00 00
	00 00		 mov	 QWORD PTR dllName$[rsp], 0

; 76   :     FARPROC functionAddress = NULL;

  002d8	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR functionAddress$[rsp], 0
$_import$52:

; 77   : _import:
; 78   :     PIMAGE_DATA_DIRECTORY importDirectory = &pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

  002e4	b8 08 00 00 00	 mov	 eax, 8
  002e9	48 6b c0 01	 imul	 rax, rax, 1
  002ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pNt$[rsp]
  002f2	48 8d 84 01 88
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+136]
  002fa	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR importDirectory$[rsp], rax

; 79   :     if (!importDirectory->Size) {

  00302	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR importDirectory$[rsp]
  0030a	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0030e	75 0a		 jne	 SHORT $LN27@StubLoadPE

; 80   :         goto _bound;

  00310	e9 bc 01 00 00	 jmp	 $LN28@StubLoadPE
  00315	e9 b7 01 00 00	 jmp	 $_bound$53
$LN27@StubLoadPE:

; 81   :     }
; 82   :     // interate through import descriptors
; 83   :     PIMAGE_IMPORT_DESCRIPTOR importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)lpOrigLoadAddress + importDirectory->VirtualAddress);

  0031a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR importDirectory$[rsp]
  00322	8b 00		 mov	 eax, DWORD PTR [rax]
  00324	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  00329	48 03 c8	 add	 rcx, rax
  0032c	48 8b c1	 mov	 rax, rcx
  0032f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR importDescriptor$[rsp], rax

; 84   :     if (!importDescriptor) {

  00337	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR importDescriptor$[rsp], 0
  00340	75 05		 jne	 SHORT $LN29@StubLoadPE

; 85   :         return;

  00342	e9 7e 07 00 00	 jmp	 $LN1@StubLoadPE
$LN29@StubLoadPE:
$LN2@StubLoadPE:

; 86   :     }
; 87   :     // solve each dll
; 88   :     while (importDescriptor->OriginalFirstThunk) {

  00347	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR importDescriptor$[rsp]
  0034f	83 38 00	 cmp	 DWORD PTR [rax], 0
  00352	0f 84 79 01 00
	00		 je	 $LN3@StubLoadPE

; 89   :         dllName = (LPCSTR)((BYTE*)lpOrigLoadAddress + importDescriptor->Name);

  00358	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR importDescriptor$[rsp]
  00360	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00363	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  00368	48 03 c8	 add	 rcx, rax
  0036b	48 8b c1	 mov	 rax, rcx
  0036e	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR dllName$[rsp], rax

; 90   :         HMODULE hModuleDLL = LoadLibraryA(dllName);

  00376	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR dllName$[rsp]
  0037e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  00384	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR hModuleDLL$13[rsp], rax

; 91   :         if (!hModuleDLL) {

  0038c	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR hModuleDLL$13[rsp], 0
  00395	75 05		 jne	 SHORT $LN30@StubLoadPE

; 92   :             return;

  00397	e9 29 07 00 00	 jmp	 $LN1@StubLoadPE
$LN30@StubLoadPE:

; 93   :         }
; 94   :         PIMAGE_THUNK_DATA pINT = (PIMAGE_THUNK_DATA)((BYTE*)lpOrigLoadAddress + importDescriptor->OriginalFirstThunk);

  0039c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR importDescriptor$[rsp]
  003a4	8b 00		 mov	 eax, DWORD PTR [rax]
  003a6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  003ab	48 03 c8	 add	 rcx, rax
  003ae	48 8b c1	 mov	 rax, rcx
  003b1	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pINT$5[rsp], rax

; 95   :         PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)((BYTE*)lpOrigLoadAddress + importDescriptor->FirstThunk);

  003b9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR importDescriptor$[rsp]
  003c1	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  003c4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  003c9	48 03 c8	 add	 rcx, rax
  003cc	48 8b c1	 mov	 rax, rcx
  003cf	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR pIAT$12[rsp], rax
$LN4@StubLoadPE:

; 96   :         while (pINT->u1.AddressOfData) {

  003d7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pINT$5[rsp]
  003df	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  003e3	0f 84 cf 00 00
	00		 je	 $LN5@StubLoadPE

; 97   :             functionID = NULL;

  003e9	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR functionID$[rsp], 0

; 98   :             if (pINT->u1.Ordinal & IMAGE_ORDINAL_FLAG64) {

  003f5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pINT$5[rsp]
  003fd	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00407	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0040a	48 23 c1	 and	 rax, rcx
  0040d	48 85 c0	 test	 rax, rax
  00410	74 1b		 je	 SHORT $LN31@StubLoadPE

; 99   :                 // import by ordinal
; 100  :                 functionID = (LPCSTR)(pINT->u1.Ordinal & 0xFFFF);

  00412	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pINT$5[rsp]
  0041a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0041d	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00423	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR functionID$[rsp], rax

; 101  :             } else {

  0042b	eb 1d		 jmp	 SHORT $LN32@StubLoadPE
$LN31@StubLoadPE:

; 102  :                 // import by name
; 103  :                 functionID = (LPCSTR)((PIMAGE_IMPORT_BY_NAME)((BYTE*)lpOrigLoadAddress + pINT->u1.AddressOfData))->Name;

  0042d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pINT$5[rsp]
  00435	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00438	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  0043d	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  00442	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR functionID$[rsp], rax
$LN32@StubLoadPE:

; 104  :             }
; 105  :             functionAddress = GetProcAddress(hModuleDLL, functionID);

  0044a	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR functionID$[rsp]
  00452	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR hModuleDLL$13[rsp]
  0045a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00460	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR functionAddress$[rsp], rax

; 106  :             if (!functionAddress) {

  00468	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR functionAddress$[rsp], 0
  00471	75 05		 jne	 SHORT $LN33@StubLoadPE

; 107  :                 return;

  00473	e9 4d 06 00 00	 jmp	 $LN1@StubLoadPE
$LN33@StubLoadPE:

; 108  :             }
; 109  :             (pIAT++)->u1.Function = (ULONGLONG)functionAddress;

  00478	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pIAT$12[rsp]
  00480	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR functionAddress$[rsp]
  00488	48 89 08	 mov	 QWORD PTR [rax], rcx
  0048b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pIAT$12[rsp]
  00493	48 83 c0 08	 add	 rax, 8
  00497	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR pIAT$12[rsp], rax

; 110  :             pINT += 1;

  0049f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pINT$5[rsp]
  004a7	48 83 c0 08	 add	 rax, 8
  004ab	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pINT$5[rsp], rax

; 111  :         }

  004b3	e9 1f ff ff ff	 jmp	 $LN4@StubLoadPE
$LN5@StubLoadPE:

; 112  :         importDescriptor += 1;

  004b8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR importDescriptor$[rsp]
  004c0	48 83 c0 14	 add	 rax, 20
  004c4	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR importDescriptor$[rsp], rax

; 113  :     }

  004cc	e9 76 fe ff ff	 jmp	 $LN2@StubLoadPE
$LN3@StubLoadPE:
$LN28@StubLoadPE:
$_bound$53:

; 114  : _bound:
; 115  :     PIMAGE_DATA_DIRECTORY boundDirectory = &pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT];

  004d1	b8 08 00 00 00	 mov	 eax, 8
  004d6	48 6b c0 0b	 imul	 rax, rax, 11
  004da	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pNt$[rsp]
  004df	48 8d 84 01 88
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+136]
  004e7	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR boundDirectory$[rsp], rax

; 116  :     if (!boundDirectory->Size) {

  004ef	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR boundDirectory$[rsp]
  004f7	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  004fb	75 0a		 jne	 SHORT $LN34@StubLoadPE

; 117  :         goto _delayed;

  004fd	e9 2d 01 00 00	 jmp	 $LN35@StubLoadPE
  00502	e9 28 01 00 00	 jmp	 $_delayed$54
$LN34@StubLoadPE:

; 118  :     }
; 119  : 
; 120  :     PIMAGE_BOUND_IMPORT_DESCRIPTOR boundDescriptor = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)((BYTE*)lpOrigLoadAddress + boundDirectory->VirtualAddress);

  00507	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR boundDirectory$[rsp]
  0050f	8b 00		 mov	 eax, DWORD PTR [rax]
  00511	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  00516	48 03 c8	 add	 rcx, rax
  00519	48 8b c1	 mov	 rax, rcx
  0051c	48 89 44 24 60	 mov	 QWORD PTR boundDescriptor$[rsp], rax
$LN50@StubLoadPE:
$LN6@StubLoadPE:

; 121  :     while (boundDescriptor->TimeDateStamp) {

  00521	48 8b 44 24 60	 mov	 rax, QWORD PTR boundDescriptor$[rsp]
  00526	83 38 00	 cmp	 DWORD PTR [rax], 0
  00529	0f 84 00 01 00
	00		 je	 $LN7@StubLoadPE

; 122  :         LPCSTR dllName = (LPCSTR)((BYTE*)lpOrigLoadAddress + boundDescriptor->OffsetModuleName);

  0052f	48 8b 44 24 60	 mov	 rax, QWORD PTR boundDescriptor$[rsp]
  00534	0f b7 40 04	 movzx	 eax, WORD PTR [rax+4]
  00538	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  0053d	48 03 c8	 add	 rcx, rax
  00540	48 8b c1	 mov	 rax, rcx
  00543	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR dllName$16[rsp], rax

; 123  :         HMODULE hModule = LoadLibraryA(dllName);

  0054b	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR dllName$16[rsp]
  00553	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  00559	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR hModule$17[rsp], rax

; 124  :         if (!hModule) {

  00561	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR hModule$17[rsp], 0
  0056a	75 05		 jne	 SHORT $LN36@StubLoadPE

; 125  :             return;

  0056c	e9 54 05 00 00	 jmp	 $LN1@StubLoadPE
$LN36@StubLoadPE:

; 126  :         }
; 127  :         if (!boundDescriptor->NumberOfModuleForwarderRefs) {

  00571	48 8b 44 24 60	 mov	 rax, QWORD PTR boundDescriptor$[rsp]
  00576	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0057a	85 c0		 test	 eax, eax
  0057c	75 10		 jne	 SHORT $LN37@StubLoadPE

; 128  :             boundDescriptor += 1;

  0057e	48 8b 44 24 60	 mov	 rax, QWORD PTR boundDescriptor$[rsp]
  00583	48 83 c0 08	 add	 rax, 8
  00587	48 89 44 24 60	 mov	 QWORD PTR boundDescriptor$[rsp], rax

; 129  :             continue;

  0058c	eb 93		 jmp	 SHORT $LN6@StubLoadPE
$LN37@StubLoadPE:

; 130  :         }
; 131  : 
; 132  :         PIMAGE_BOUND_FORWARDER_REF forwarderRef = (PIMAGE_BOUND_FORWARDER_REF)(boundDescriptor + 1);

  0058e	48 8b 44 24 60	 mov	 rax, QWORD PTR boundDescriptor$[rsp]
  00593	48 83 c0 08	 add	 rax, 8
  00597	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR forwarderRef$9[rsp], rax

; 133  :         for (unsigned int i = 0; i < boundDescriptor->NumberOfModuleForwarderRefs; i++) {

  0059f	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  005a7	eb 0a		 jmp	 SHORT $LN10@StubLoadPE
$LN8@StubLoadPE:
  005a9	8b 44 24 6c	 mov	 eax, DWORD PTR i$3[rsp]
  005ad	ff c0		 inc	 eax
  005af	89 44 24 6c	 mov	 DWORD PTR i$3[rsp], eax
$LN10@StubLoadPE:
  005b3	48 8b 44 24 60	 mov	 rax, QWORD PTR boundDescriptor$[rsp]
  005b8	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  005bc	39 44 24 6c	 cmp	 DWORD PTR i$3[rsp], eax
  005c0	73 5b		 jae	 SHORT $LN9@StubLoadPE

; 134  :             LPCSTR forwarderDLLName = (LPCSTR)((BYTE*)lpOrigLoadAddress + forwarderRef->OffsetModuleName);

  005c2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR forwarderRef$9[rsp]
  005ca	0f b7 40 04	 movzx	 eax, WORD PTR [rax+4]
  005ce	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  005d3	48 03 c8	 add	 rcx, rax
  005d6	48 8b c1	 mov	 rax, rcx
  005d9	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR forwarderDLLName$18[rsp], rax

; 135  :             HMODULE hForwarderModule = LoadLibraryA(forwarderDLLName);

  005e1	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR forwarderDLLName$18[rsp]
  005e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  005ef	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR hForwarderModule$19[rsp], rax

; 136  :             if (!hForwarderModule) {

  005f7	48 83 bc 24 90
	01 00 00 00	 cmp	 QWORD PTR hForwarderModule$19[rsp], 0
  00600	75 05		 jne	 SHORT $LN38@StubLoadPE

; 137  :                 return;

  00602	e9 be 04 00 00	 jmp	 $LN1@StubLoadPE
$LN38@StubLoadPE:

; 138  :             }
; 139  :             forwarderRef += 1;

  00607	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR forwarderRef$9[rsp]
  0060f	48 83 c0 08	 add	 rax, 8
  00613	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR forwarderRef$9[rsp], rax

; 140  :         }

  0061b	eb 8c		 jmp	 SHORT $LN8@StubLoadPE
$LN9@StubLoadPE:

; 141  :         boundDescriptor = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)forwarderRef;

  0061d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR forwarderRef$9[rsp]
  00625	48 89 44 24 60	 mov	 QWORD PTR boundDescriptor$[rsp], rax

; 142  :     }

  0062a	e9 f2 fe ff ff	 jmp	 $LN50@StubLoadPE
$LN7@StubLoadPE:
$LN35@StubLoadPE:
$_delayed$54:

; 143  : _delayed:
; 144  :     PIMAGE_DATA_DIRECTORY delayedDirectory = &pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];

  0062f	b8 08 00 00 00	 mov	 eax, 8
  00634	48 6b c0 0d	 imul	 rax, rax, 13
  00638	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pNt$[rsp]
  0063d	48 8d 84 01 88
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+136]
  00645	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR delayedDirectory$[rsp], rax

; 145  :     if (!delayedDirectory->Size) {

  0064d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR delayedDirectory$[rsp]
  00655	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00659	75 0a		 jne	 SHORT $LN39@StubLoadPE

; 146  :         goto _reloc;

  0065b	e9 b2 01 00 00	 jmp	 $LN40@StubLoadPE
  00660	e9 ad 01 00 00	 jmp	 $_reloc$55
$LN39@StubLoadPE:

; 147  :     }
; 148  : 
; 149  :     PIMAGE_DELAYLOAD_DESCRIPTOR delayloadDescriptor = (PIMAGE_DELAYLOAD_DESCRIPTOR)((BYTE*)lpOrigLoadAddress + delayedDirectory->VirtualAddress);

  00665	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR delayedDirectory$[rsp]
  0066d	8b 00		 mov	 eax, DWORD PTR [rax]
  0066f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  00674	48 03 c8	 add	 rcx, rax
  00677	48 8b c1	 mov	 rax, rcx
  0067a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR delayloadDescriptor$[rsp], rax
$LN11@StubLoadPE:

; 150  :     while (delayloadDescriptor->DllNameRVA) {

  00682	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR delayloadDescriptor$[rsp]
  0068a	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0068e	0f 84 7e 01 00
	00		 je	 $LN12@StubLoadPE

; 151  :         LPCSTR dllName = (LPCSTR)((BYTE*)lpOrigLoadAddress + delayloadDescriptor->DllNameRVA);

  00694	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR delayloadDescriptor$[rsp]
  0069c	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0069f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  006a4	48 03 c8	 add	 rcx, rax
  006a7	48 8b c1	 mov	 rax, rcx
  006aa	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR dllName$20[rsp], rax

; 152  :         HMODULE hDelayModule = LoadLibraryA(dllName);

  006b2	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR dllName$20[rsp]
  006ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  006c0	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR hDelayModule$11[rsp], rax

; 153  :         if (!hDelayModule) {

  006c8	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR hDelayModule$11[rsp], 0
  006d1	75 05		 jne	 SHORT $LN41@StubLoadPE

; 154  :             return;

  006d3	e9 ed 03 00 00	 jmp	 $LN1@StubLoadPE
$LN41@StubLoadPE:

; 155  :         }
; 156  : 
; 157  :         PIMAGE_THUNK_DATA delayedINT = (PIMAGE_THUNK_DATA)((BYTE*)lpOrigLoadAddress + delayloadDescriptor->ImportNameTableRVA);

  006d8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR delayloadDescriptor$[rsp]
  006e0	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  006e3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  006e8	48 03 c8	 add	 rcx, rax
  006eb	48 8b c1	 mov	 rax, rcx
  006ee	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR delayedINT$6[rsp], rax

; 158  :         PIMAGE_THUNK_DATA delayedIAT = (PIMAGE_THUNK_DATA)((BYTE*)lpOrigLoadAddress + delayloadDescriptor->ImportAddressTableRVA);

  006f6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR delayloadDescriptor$[rsp]
  006fe	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00701	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  00706	48 03 c8	 add	 rcx, rax
  00709	48 8b c1	 mov	 rax, rcx
  0070c	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR delayedIAT$7[rsp], rax
$LN13@StubLoadPE:

; 159  :         while (delayedIAT->u1.AddressOfData) {

  00714	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR delayedIAT$7[rsp]
  0071c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00720	0f 84 d3 00 00
	00		 je	 $LN14@StubLoadPE

; 160  :             FARPROC delayedFunction = NULL;

  00726	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR delayedFunction$10[rsp], 0

; 161  :             if (delayedINT->u1.Ordinal & IMAGE_ORDINAL_FLAG64) {

  00732	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR delayedINT$6[rsp]
  0073a	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00744	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00747	48 23 c1	 and	 rax, rcx
  0074a	48 85 c0	 test	 rax, rax
  0074d	74 2c		 je	 SHORT $LN42@StubLoadPE

; 162  :                 delayedFunction = GetProcAddress(hDelayModule, (LPCSTR)(delayedINT->u1.Ordinal & 0xFFFF));

  0074f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR delayedINT$6[rsp]
  00757	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0075a	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00760	48 8b d0	 mov	 rdx, rax
  00763	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR hDelayModule$11[rsp]
  0076b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00771	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR delayedFunction$10[rsp], rax

; 163  :             } else {

  00779	eb 2e		 jmp	 SHORT $LN43@StubLoadPE
$LN42@StubLoadPE:

; 164  :                 delayedFunction = GetProcAddress(hDelayModule, ((PIMAGE_IMPORT_BY_NAME)((BYTE*)lpOrigLoadAddress + delayedINT->u1.AddressOfData))->Name);

  0077b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR delayedINT$6[rsp]
  00783	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00786	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  0078b	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  00790	48 8b d0	 mov	 rdx, rax
  00793	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR hDelayModule$11[rsp]
  0079b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  007a1	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR delayedFunction$10[rsp], rax
$LN43@StubLoadPE:

; 165  :             }
; 166  :             if (!delayedFunction) {

  007a9	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR delayedFunction$10[rsp], 0
  007b2	75 05		 jne	 SHORT $LN44@StubLoadPE

; 167  :                 return;

  007b4	e9 0c 03 00 00	 jmp	 $LN1@StubLoadPE
$LN44@StubLoadPE:

; 168  :             }
; 169  :             (delayedIAT++)->u1.Function = (ULONGLONG)delayedFunction;

  007b9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR delayedIAT$7[rsp]
  007c1	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR delayedFunction$10[rsp]
  007c9	48 89 08	 mov	 QWORD PTR [rax], rcx
  007cc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR delayedIAT$7[rsp]
  007d4	48 83 c0 08	 add	 rax, 8
  007d8	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR delayedIAT$7[rsp], rax

; 170  :             delayedINT += 1;

  007e0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR delayedINT$6[rsp]
  007e8	48 83 c0 08	 add	 rax, 8
  007ec	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR delayedINT$6[rsp], rax

; 171  :         }

  007f4	e9 1b ff ff ff	 jmp	 $LN13@StubLoadPE
$LN14@StubLoadPE:

; 172  :         delayloadDescriptor += 1;

  007f9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR delayloadDescriptor$[rsp]
  00801	48 83 c0 20	 add	 rax, 32			; 00000020H
  00805	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR delayloadDescriptor$[rsp], rax

; 173  :     }

  0080d	e9 70 fe ff ff	 jmp	 $LN11@StubLoadPE
$LN12@StubLoadPE:
$LN40@StubLoadPE:
$_reloc$55:

; 174  : _reloc:
; 175  :     ULONGLONG delta = (ULONGLONG)((ULONGLONG)lpOrigLoadAddress - pNt->OptionalHeader.ImageBase);

  00812	48 8b 44 24 50	 mov	 rax, QWORD PTR pNt$[rsp]
  00817	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0081b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  00820	48 2b c8	 sub	 rcx, rax
  00823	48 8b c1	 mov	 rax, rcx
  00826	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR delta$[rsp], rax

; 176  :     PIMAGE_DATA_DIRECTORY relocationDirectory = &pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

  0082e	b8 08 00 00 00	 mov	 eax, 8
  00833	48 6b c0 05	 imul	 rax, rax, 5
  00837	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pNt$[rsp]
  0083c	48 8d 84 01 88
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+136]
  00844	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR relocationDirectory$[rsp], rax

; 177  :     if (!relocationDirectory->Size) {

  0084c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR relocationDirectory$[rsp]
  00854	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00858	75 0a		 jne	 SHORT $LN45@StubLoadPE

; 178  :         goto _run;

  0085a	e9 a5 01 00 00	 jmp	 $LN46@StubLoadPE
  0085f	e9 a0 01 00 00	 jmp	 $_run$56
$LN45@StubLoadPE:

; 179  :     }
; 180  : 
; 181  :     PIMAGE_BASE_RELOCATION relocation = (PIMAGE_BASE_RELOCATION)((BYTE*)lpOrigLoadAddress + relocationDirectory->VirtualAddress);

  00864	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR relocationDirectory$[rsp]
  0086c	8b 00		 mov	 eax, DWORD PTR [rax]
  0086e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  00873	48 03 c8	 add	 rcx, rax
  00876	48 8b c1	 mov	 rax, rcx
  00879	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR relocation$[rsp], rax
$LN15@StubLoadPE:

; 182  : 
; 183  :     while (relocation->VirtualAddress) {

  00881	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR relocation$[rsp]
  00889	83 38 00	 cmp	 DWORD PTR [rax], 0
  0088c	0f 84 72 01 00
	00		 je	 $LN16@StubLoadPE

; 184  :         BYTE* relocationBase = (BYTE*)lpOrigLoadAddress + relocation->VirtualAddress;

  00892	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR relocation$[rsp]
  0089a	8b 00		 mov	 eax, DWORD PTR [rax]
  0089c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  008a1	48 03 c8	 add	 rcx, rax
  008a4	48 8b c1	 mov	 rax, rcx
  008a7	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR relocationBase$15[rsp], rax

; 185  : 
; 186  :         unsigned long long numEntries = (relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);

  008af	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR relocation$[rsp]
  008b7	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  008ba	48 83 e8 08	 sub	 rax, 8
  008be	33 d2		 xor	 edx, edx
  008c0	b9 02 00 00 00	 mov	 ecx, 2
  008c5	48 f7 f1	 div	 rcx
  008c8	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR numEntries$14[rsp], rax

; 187  :             //debug
; 188  :             WriteFile(hLog, &numEntries, 8, &bytes, NULL);

  008d0	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  008d9	4c 8d 4c 24 58	 lea	 r9, QWORD PTR bytes$[rsp]
  008de	41 b8 08 00 00
	00		 mov	 r8d, 8
  008e4	48 8d 94 24 48
	01 00 00	 lea	 rdx, QWORD PTR numEntries$14[rsp]
  008ec	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR hLog$[rsp]
  008f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile

; 189  :             WriteFile(hLog, "\n\n\n\n", 4, &bytes, NULL);

  008fa	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00903	4c 8d 4c 24 58	 lea	 r9, QWORD PTR bytes$[rsp]
  00908	41 b8 04 00 00
	00		 mov	 r8d, 4
  0090e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG96963
  00915	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR hLog$[rsp]
  0091d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile

; 190  :             //debug
; 191  :         PWORD relocationEntry = reinterpret_cast<PWORD>((BYTE*)(relocation + 1));

  00923	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR relocation$[rsp]
  0092b	48 83 c0 08	 add	 rax, 8
  0092f	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR relocationEntry$8[rsp], rax

; 192  :         for (unsigned int i = 0; i < numEntries; i++) {

  00937	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0
  0093f	eb 0a		 jmp	 SHORT $LN19@StubLoadPE
$LN17@StubLoadPE:
  00941	8b 44 24 70	 mov	 eax, DWORD PTR i$4[rsp]
  00945	ff c0		 inc	 eax
  00947	89 44 24 70	 mov	 DWORD PTR i$4[rsp], eax
$LN19@StubLoadPE:
  0094b	8b 44 24 70	 mov	 eax, DWORD PTR i$4[rsp]
  0094f	48 3b 84 24 48
	01 00 00	 cmp	 rax, QWORD PTR numEntries$14[rsp]
  00957	0f 83 81 00 00
	00		 jae	 $LN18@StubLoadPE

; 193  :             WORD type = *relocationEntry >> 12;

  0095d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR relocationEntry$8[rsp]
  00965	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00968	c1 f8 0c	 sar	 eax, 12
  0096b	66 89 44 24 68	 mov	 WORD PTR type$2[rsp], ax

; 194  :             WORD offset = *relocationEntry & 0x0FFF;

  00970	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR relocationEntry$8[rsp]
  00978	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0097b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00980	66 89 44 24 48	 mov	 WORD PTR offset$1[rsp], ax

; 195  :             if(type == IMAGE_REL_BASED_DIR64) {

  00985	0f b7 44 24 68	 movzx	 eax, WORD PTR type$2[rsp]
  0098a	83 f8 0a	 cmp	 eax, 10
  0098d	75 36		 jne	 SHORT $LN47@StubLoadPE

; 196  :                 *(ULONGLONG*)(relocationBase + offset) = getQwordLE(((BYTE*)relocationBase + offset), 0) + delta;

  0098f	0f b7 44 24 48	 movzx	 eax, WORD PTR offset$1[rsp]
  00994	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR relocationBase$15[rsp]
  0099c	48 03 c8	 add	 rcx, rax
  0099f	48 8b c1	 mov	 rax, rcx
  009a2	33 d2		 xor	 edx, edx
  009a4	48 8b c8	 mov	 rcx, rax
  009a7	e8 00 00 00 00	 call	 ?getQwordLE@@YA_KPEAEH@Z ; getQwordLE
  009ac	48 03 84 24 a0
	01 00 00	 add	 rax, QWORD PTR delta$[rsp]
  009b4	0f b7 4c 24 48	 movzx	 ecx, WORD PTR offset$1[rsp]
  009b9	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR relocationBase$15[rsp]
  009c1	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax
$LN47@StubLoadPE:

; 197  :             }
; 198  :             relocationEntry += 1;

  009c5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR relocationEntry$8[rsp]
  009cd	48 83 c0 02	 add	 rax, 2
  009d1	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR relocationEntry$8[rsp], rax

; 199  :         }

  009d9	e9 63 ff ff ff	 jmp	 $LN17@StubLoadPE
$LN18@StubLoadPE:

; 200  :         relocation = (PIMAGE_BASE_RELOCATION)((BYTE*)relocation + relocation->SizeOfBlock);

  009de	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR relocation$[rsp]
  009e6	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  009e9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR relocation$[rsp]
  009f1	48 03 c8	 add	 rcx, rax
  009f4	48 8b c1	 mov	 rax, rcx
  009f7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR relocation$[rsp], rax

; 201  :     }

  009ff	e9 7d fe ff ff	 jmp	 $LN15@StubLoadPE
$LN16@StubLoadPE:
$LN46@StubLoadPE:
$_run$56:

; 202  : _run:
; 203  :     HANDLE hDump = CreateFile("dump_by_stub.exe", GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  00a04	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00a0d	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  00a15	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00a1d	45 33 c9	 xor	 r9d, r9d
  00a20	41 b8 02 00 00
	00		 mov	 r8d, 2
  00a26	ba 00 00 00 40	 mov	 edx, 1073741824		; 40000000H
  00a2b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG96965
  00a32	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  00a38	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR hDump$[rsp], rax

; 204  :     WriteFile(hDump, (BYTE*)lpOrigLoadAddress, pSec->PointerToRelocations, &bytes, NULL);

  00a40	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00a49	4c 8d 4c 24 58	 lea	 r9, QWORD PTR bytes$[rsp]
  00a4e	48 8b 44 24 78	 mov	 rax, QWORD PTR pSec$[rsp]
  00a53	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  00a57	48 8b 54 24 40	 mov	 rdx, QWORD PTR lpOrigLoadAddress$[rsp]
  00a5c	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR hDump$[rsp]
  00a64	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile

; 205  : 
; 206  :     pNt->OptionalHeader.ImageBase = (ULONGLONG)lpOrigLoadAddress;

  00a6a	48 8b 44 24 50	 mov	 rax, QWORD PTR pNt$[rsp]
  00a6f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  00a74	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 207  :     LPTHREAD_START_ROUTINE entryPoint = (LPTHREAD_START_ROUTINE)(pNt->OptionalHeader.AddressOfEntryPoint + (BYTE*)lpOrigLoadAddress);

  00a78	48 8b 44 24 50	 mov	 rax, QWORD PTR pNt$[rsp]
  00a7d	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00a80	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  00a85	48 03 c8	 add	 rcx, rax
  00a88	48 8b c1	 mov	 rax, rcx
  00a8b	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR entryPoint$[rsp], rax

; 208  : 
; 209  :     DWORD oldProtect;
; 210  :     if (!VirtualProtect(lpOrigLoadAddress, pSec->PointerToRelocations, PAGE_EXECUTE_READWRITE, &oldProtect)) {

  00a93	48 8b 44 24 78	 mov	 rax, QWORD PTR pSec$[rsp]
  00a98	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00a9b	4c 8d 8c 24 58
	01 00 00	 lea	 r9, QWORD PTR oldProtect$[rsp]
  00aa3	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00aa9	8b d0		 mov	 edx, eax
  00aab	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lpOrigLoadAddress$[rsp]
  00ab0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualProtect
  00ab6	85 c0		 test	 eax, eax
  00ab8	75 02		 jne	 SHORT $LN48@StubLoadPE

; 211  :         return;

  00aba	eb 09		 jmp	 SHORT $LN1@StubLoadPE
$LN48@StubLoadPE:

; 212  :     }
; 213  :     entryPoint(NULL);

  00abc	33 c9		 xor	 ecx, ecx
  00abe	ff 94 24 b0 01
	00 00		 call	 QWORD PTR entryPoint$[rsp]
$LN1@StubLoadPE:

; 214  : 
; 215  : }

  00ac5	48 81 c4 d8 01
	00 00		 add	 rsp, 472		; 000001d8H
  00acc	c3		 ret	 0
StubLoadPE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\licenta\mypacker\stub\stub.cpp
_TEXT	SEGMENT
pdata$ = 8
index$ = 16
?getQwordLE@@YA_KPEAEH@Z PROC				; getQwordLE

; 19   : ULONGLONG getQwordLE(BYTE *pdata, int index) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 20   :     return pdata[index + 0] | (ULONGLONG (pdata[index + 1]) << 8) | (ULONGLONG (pdata[index + 2]) << 16) | (ULONGLONG (pdata[index + 3]) << 24) |

  00009	8b 44 24 10	 mov	 eax, DWORD PTR index$[rsp]
  0000d	48 98		 cdqe
  0000f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pdata$[rsp]
  00014	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00018	8b 4c 24 10	 mov	 ecx, DWORD PTR index$[rsp]
  0001c	ff c1		 inc	 ecx
  0001e	48 63 c9	 movsxd	 rcx, ecx
  00021	48 8b 54 24 08	 mov	 rdx, QWORD PTR pdata$[rsp]
  00026	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0002a	48 c1 e1 08	 shl	 rcx, 8
  0002e	48 0b c1	 or	 rax, rcx
  00031	8b 4c 24 10	 mov	 ecx, DWORD PTR index$[rsp]
  00035	83 c1 02	 add	 ecx, 2
  00038	48 63 c9	 movsxd	 rcx, ecx
  0003b	48 8b 54 24 08	 mov	 rdx, QWORD PTR pdata$[rsp]
  00040	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00044	48 c1 e1 10	 shl	 rcx, 16
  00048	48 0b c1	 or	 rax, rcx
  0004b	8b 4c 24 10	 mov	 ecx, DWORD PTR index$[rsp]
  0004f	83 c1 03	 add	 ecx, 3
  00052	48 63 c9	 movsxd	 rcx, ecx
  00055	48 8b 54 24 08	 mov	 rdx, QWORD PTR pdata$[rsp]
  0005a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0005e	48 c1 e1 18	 shl	 rcx, 24
  00062	48 0b c1	 or	 rax, rcx
  00065	8b 4c 24 10	 mov	 ecx, DWORD PTR index$[rsp]
  00069	83 c1 04	 add	 ecx, 4
  0006c	48 63 c9	 movsxd	 rcx, ecx
  0006f	48 8b 54 24 08	 mov	 rdx, QWORD PTR pdata$[rsp]
  00074	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00078	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  0007c	48 0b c1	 or	 rax, rcx
  0007f	8b 4c 24 10	 mov	 ecx, DWORD PTR index$[rsp]
  00083	83 c1 05	 add	 ecx, 5
  00086	48 63 c9	 movsxd	 rcx, ecx
  00089	48 8b 54 24 08	 mov	 rdx, QWORD PTR pdata$[rsp]
  0008e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00092	48 c1 e1 28	 shl	 rcx, 40			; 00000028H
  00096	48 0b c1	 or	 rax, rcx
  00099	8b 4c 24 10	 mov	 ecx, DWORD PTR index$[rsp]
  0009d	83 c1 06	 add	 ecx, 6
  000a0	48 63 c9	 movsxd	 rcx, ecx
  000a3	48 8b 54 24 08	 mov	 rdx, QWORD PTR pdata$[rsp]
  000a8	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000ac	48 c1 e1 30	 shl	 rcx, 48			; 00000030H
  000b0	48 0b c1	 or	 rax, rcx
  000b3	8b 4c 24 10	 mov	 ecx, DWORD PTR index$[rsp]
  000b7	83 c1 07	 add	 ecx, 7
  000ba	48 63 c9	 movsxd	 rcx, ecx
  000bd	48 8b 54 24 08	 mov	 rdx, QWORD PTR pdata$[rsp]
  000c2	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000c6	48 c1 e1 38	 shl	 rcx, 56			; 00000038H
  000ca	48 0b c1	 or	 rax, rcx

; 21   :         (ULONGLONG (pdata[index + 4]) << 32) | (ULONGLONG (pdata[index + 5]) << 40) | (ULONGLONG (pdata[index + 6]) << 48) | (ULONGLONG (pdata[index + 7]) << 56);
; 22   : }

  000cd	c3		 ret	 0
?getQwordLE@@YA_KPEAEH@Z ENDP				; getQwordLE
_TEXT	ENDS
END
